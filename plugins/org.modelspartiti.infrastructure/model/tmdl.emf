@"http://www.eclipse.org/OCL/Import"(ecore="http://www.eclipse.org/emf/2002/Ecore")
@namespace(uri="http://www.modelspartiti.org/infrastructure/tmdl", prefix="tmdl")
package tmdl;

@namespace(uri="http://www.modelspartiti.org/infrastructure/tmdl/scenario", prefix="scn")
package scenario {
  class Scenario {
    id attr String[1] name;
    val Variant[+] variants;
    ref Variant[1] root;
  }

  abstract class Variant {
    id attr String[1] name;
    val core.Assignment[*] assignments;
  }

  class VariantAtomic extends Variant {
    ref library.TemplateAtomic[1] template;
    attr String[*] labels;
  }

  class VariantComposite extends Variant {
    ref library.TemplateComposite[1] template;
    val BlockRealization[+] realizations;
  }

  class BlockRealization {
    ref library.Block[1] block;
    ref Variant[1] variant;
  }

}

@namespace(uri="http://www.modelspartiti.org/infrastructure/tmdl/library", prefix="lib")
package library {
  class Library {
    id attr String[1] name;
    val ModelInterface[+] interfaces;
    val TemplateSpecification[+] templates;
  }

  class ModelInterface {
    id attr String[1] name;
    val InterfaceVariable[+] variables;
    val core.Parameter[*] parameters;
  }

  abstract class TemplateSpecification {
    id attr String[1] name;
    ref ModelInterface[+] interfaces;
    ref core.Parameter parameters;
  }

  class TemplateAtomic extends TemplateSpecification {
    attr String[1] source;
    attr String[*] labels;
  }

  class TemplateComposite extends TemplateSpecification {
    val CompositionRule[+] rules;
    val Block[+] blocks;
  }

  class Block {
    attr String[*] labels;
    val core.Multiplicity[1] multiplicity;
    ref ModelInterface[*] requiredInterfaces;
  }

  class InterfaceVariable {
    id attr String[1] name;
    attr String[*] labels;
    val core.Multiplicity[1] multiplicity;
  }

  abstract class CompositionRule {
    attr String[1] name;
    ref InterfaceVariable[*] variables;
  }

  class CompositionRuleAll extends CompositionRule {
  }

  class CompositionRuleMatch extends CompositionRule {
    attr String[*] labels;
  }

  class CompositionRuleForwards extends CompositionRule {
  }

}

@Ecore(invocationDelegates="http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot", settingDelegates="http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot", validationDelegates="http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot")
@namespace(uri="http://www.modelspartiti.org/infrastructure/tmdl/core", prefix="core")
package core {
  abstract interface ConcreteModel {
    op TemplateModel[1] templatize();
  }

  abstract interface TemplateModel {
    op ConcreteModel[1] concretize(Assignment[*] parameterValues);
  }

  abstract class Parameter {
    attr String[1] name;
  }

  class ParameterSimple extends Parameter {
  }

  class ParameterArray extends Parameter {
  }

  abstract class Assignment {
  }

  class AssignmentSimple extends Assignment {
    ref ParameterSimple[1] parameter;
    attr double[1] value;
  }

  class AssignmentArray extends Assignment {
    ref ParameterArray[1] parameter;
    attr double[*] values;
  }

  abstract interface Multiplicity {

    @"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(body="asSequence(Assignment.allInstances())")
    op int[*] asSequence();
    op int[*] asSequence(!ordered Assignment[*] assignments);
  }

  class MultiplicityValue extends Multiplicity {

    @"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(body="
				if value = 0 then Sequence{}
				else Sequence{1..value} endif")
    op int[*] asSequence(!ordered Assignment[*] assignments);
    attr double[1] value;
  }

  class MultiplicityArray extends Multiplicity {

    @"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(body="values")
    op int[*] asSequence(!ordered Assignment[*] assignments);
    attr int[+] values;
  }

  class MultiplicityParametric extends Multiplicity {

    @"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(body="
				if parameter.oclIsTypeOf(AssignmentSimple) then
					let v =	assignments->selectByType(AssignmentSimple)
								->select(a | a.oclAsType(AssignmentSimple).parameter = self.parameter)
								->asSequence()->first().oclAsType(AssignmentSimple).value
					in
					if v = 0 then Sequence{} else Sequence{1..v} endif
				else
					assignments->selectByType(AssignmentArray)
								->select(a | a.oclAsType(AssignmentArray).parameter = self.parameter)
								->asSequence()->first().oclAsType(AssignmentArray).values
				endif")
    op int[*] asSequence(!ordered Assignment[*] assignments);
    ref Parameter[1] parameter;
  }

}

@Ecore(invocationDelegates="http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot", settingDelegates="http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot", validationDelegates="http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot")
@namespace(uri="http://www.modelspartiti.org/infrastructure/tmdl/expressions", prefix="exp")
package expressions {
  abstract interface TemplateExpression {
  }

  abstract interface TemplateExpressionInteger extends TemplateExpression {
    op int[1] evaluate(!ordered core.Assignment[*] assignments);

    @"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(body="evaluate(core::Assignment.allInstances())")
    op int[1] evaluate();
  }

  abstract interface TemplateExpressionReal extends TemplateExpression {
    op double[1] evaluate(!ordered core.Assignment[*] assignments);

    @"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(body="evaluate(core::Assignment.allInstances())")
    op int[1] evaluate();
  }

  abstract interface TemplateExpressionBoolean extends TemplateExpression {
    op boolean[1] evaluate(!ordered core.Assignment[*] assignments);

    @"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(body="evaluate(core::Assignment.allInstances())")
    op int[1] evaluate();
  }

  class TemplateExpressionIntegerLiteral extends TemplateExpressionInteger {

    @"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(body="value")
    op int[1] evaluate(!ordered core.Assignment[*] assignments);
    attr int[1] value;
  }

  class TemplateExpressionRealLiteral extends TemplateExpressionReal {

    @"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(body="value")
    op double[1] evaluate(!ordered core.Assignment[*] assignments);
    attr double[1] value;
  }

  class TemplateExpressionBoolaenLiteral extends TemplateExpressionBoolean {

    @"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(body="value")
    op boolean[1] evaluate(!ordered core.Assignment[*] assignments);
    attr boolean[1] value;
  }

  class TemplateExpressionIntegerFromReal extends TemplateExpressionInteger {

    @"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(body="exp.evaluate(assignments).floor()")
    op int[1] evaluate(!ordered core.Assignment[*] assignments);
    val TemplateExpressionReal[1] exp;
  }

  class TemplateExpressionRealFromInteger extends TemplateExpressionReal {

    @"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(body="exp.evaluate(assignments)")
    op double[1] evaluate(!ordered core.Assignment[*] assignments);
    val TemplateExpressionInteger[1] exp;
  }

  class TemplateExpressionParameterSimple extends TemplateExpressionReal {

    @"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(body="assignments->select(as | as.oclIsTypeOf(core::AssignmentSimple))
						->select(a | a.oclAsType(core::AssignmentSimple).parameter = self.parameter)
						->asSequence()->first().oclAsType(core::AssignmentSimple).value")
    op double[1] evaluate(!ordered core.Assignment[*] assignments);
    ref core.ParameterSimple[1] parameter;
  }

  class TemplateExpressionParameterArrayValueAt extends TemplateExpressionReal {

    @"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(body="assignments->select(as | as.oclIsTypeOf(core::AssignmentArray))
						->select(a | a.oclAsType(core::AssignmentArray).parameter = self.parameter)
						->asSequence()->first().oclAsType(core::AssignmentArray).values
						->at(position.evaluate(assignments))")
    op double[1] evaluate(!ordered core.Assignment[*] assignments);
    ref core.ParameterArray[1] parameter;
    val TemplateExpressionInteger[1] position;
  }

  class TemplateExpressionParameterArraySize extends TemplateExpressionInteger {

    @"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(body="assignments->select(as | as.oclIsTypeOf(core::AssignmentArray))
						->select(a | a.oclAsType(core::AssignmentArray).parameter = self.parameter)
						->asSequence()->first().oclAsType(core::AssignmentArray).values
						->size()")
    op int[1] evaluate(!ordered core.Assignment[*] assignments);
    ref core.ParameterArray[1] parameter;
  }

  class TemplateExpressionArrayAggregate extends TemplateExpressionReal {

    @"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(body="
				let array = assignments->select(as | as.oclIsTypeOf(core::AssignmentArray))
					->select(a | a.oclAsType(core::AssignmentArray).parameter = self.parameter)
					->asSequence()->first().oclAsType(core::AssignmentArray).values
				in
					if function = ArrayAggregateKind::sum then array->sum()
					else if function = ArrayAggregateKind::min then array->min()
					else if function = ArrayAggregateKind::max then array->max()
					else
						array->sum()/array->size()
					endif endif endif")
    op double[1] evaluate(!ordered core.Assignment[*] assignments);
    ref core.ParameterArray[1] parameter;
    attr ArrayAggregateKind[1] function;
  }

  enum ArrayAggregateKind {
    min = 1;
    max = 2;
    avg = 3;
    sum = 4;
  }

  abstract interface TemplateExpressionRealBinaryOperation extends TemplateExpressionReal {
    val TemplateExpressionReal[1] exp1;
    val TemplateExpressionReal[1] exp2;
  }

  class TemplateExpressionRealSum extends TemplateExpressionRealBinaryOperation {

    @"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(body="exp1.evaluate(assignments) + exp2.evaluate(assignments)")
    op double[1] evaluate(!ordered core.Assignment[*] assignments);
  }

  class TemplateExpressionRealSubtract extends TemplateExpressionRealBinaryOperation {

    @"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(body="exp1.evaluate(assignments) - exp2.evaluate(assignments)")
    op double[1] evaluate(!ordered core.Assignment[*] assignments);
  }

  class TemplateExpressionRealMultiply extends TemplateExpressionRealBinaryOperation {

    @"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(body="exp1.evaluate(assignments) * exp2.evaluate(assignments)")
    op double[1] evaluate(!ordered core.Assignment[*] assignments);
  }

  class TemplateExpressionRealDivide extends TemplateExpressionRealBinaryOperation {

    @"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(body="exp1.evaluate(assignments) / exp2.evaluate(assignments)")
    op double[1] evaluate(!ordered core.Assignment[*] assignments);
  }

  class TemplateExpressionRealModulo extends TemplateExpressionInteger {

    @"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(body="exp1.evaluate(assignments).mod(exp2.evaluate(assignments))")
    op int[1] evaluate(!ordered core.Assignment[*] assignments);
    val TemplateExpressionInteger[1] exp1;
    val TemplateExpressionInteger[1] exp2;
  }

  abstract interface TemplateExpressionRealUnary extends TemplateExpressionReal {
    val TemplateExpressionReal[1] exp;
  }

  class TemplateExpressionRealFloor extends TemplateExpressionInteger {

    @"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(body="exp.evaluate(assignments).floor()")
    op int[1] evaluate(!ordered core.Assignment[*] assignments);
    val TemplateExpressionReal[1] exp;
  }

  class TemplateExpressionRealCeil extends TemplateExpressionInteger {

    @"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(body="
				let n = exp.evaluate(assignments) in
				if n.floor() = n.round() then n.floor()+1
				else n.round() endif")
    op int[1] evaluate(!ordered core.Assignment[*] assignments);
    val TemplateExpressionReal[1] exp;
  }

  class TemplateExpressionRealRound extends TemplateExpressionInteger {

    @"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(body="exp.evaluate(assignments).round()")
    op int[1] evaluate(!ordered core.Assignment[*] assignments);
    val TemplateExpressionReal[1] exp;
  }

  class TemplateExpressionRealIfThenElse extends TemplateExpressionReal {

    @"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(body="
				if condition.evaluate(assignments)
				then ifTrue.evaluate(assignments)
				else ifFalse.evaluate(assignments)
				endif")
    op double[1] evaluate(!ordered core.Assignment[*] assignments);
    val TemplateExpressionBoolean[1] condition;
    val TemplateExpressionReal[1] ifTrue;
    val TemplateExpressionReal[1] ifFalse;
  }

  abstract interface TemplateExpressionBooleanUnaryOperation extends TemplateExpressionBoolean {
    val TemplateExpressionBoolean[1] exp;
  }

  class TemplateExpressionBooleanNot extends TemplateExpressionBooleanUnaryOperation {

    @"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(body="not exp.evaluate(assignments)")
    op boolean[1] evaluate(!ordered core.Assignment[*] assignments);
  }

  class TemplateExpressionBooleanToInteger extends TemplateExpressionInteger {

    @"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(body="exp.evaluate(assignments)")
    op int[1] evaluate(!ordered core.Assignment[*] assignments);
    val TemplateExpressionBoolean[1] exp;
  }

  abstract interface TemplateExpressionBooleanBinaryOperation extends TemplateExpressionBoolean {
    val TemplateExpressionBoolean[1] exp1;
    val TemplateExpressionBoolean[1] exp2;
  }

  class TemplateExpressionBooleanAnd extends TemplateExpressionBooleanBinaryOperation {

    @"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(body="exp1.evaluate(assignments) and exp2.evaluate(assignments)")
    op boolean[1] evaluate(!ordered core.Assignment[*] assignments);
  }

  class TemplateExpressionBooleanOr extends TemplateExpressionBooleanBinaryOperation {

    @"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(body="exp1.evaluate(assignments) or exp2.evaluate(assignments)")
    op boolean[1] evaluate(!ordered core.Assignment[*] assignments);
  }

}

