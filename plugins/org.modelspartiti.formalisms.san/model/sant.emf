@"http://www.eclipse.org/OCL/Import"(ecore="http://www.eclipse.org/emf/2002/Ecore")
@Ecore(invocationDelegates="http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot", settingDelegates="http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot", validationDelegates="http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot")
@namespace(uri="http://www.modelspartiti.org/templates/san/sant", prefix="sant")
package sant;

import "platform:/resource/org.modelspartiti.infrastructure/model/tmdl.ecore";

class SANT extends tmdl.core.TemplateModel {
  id attr String[1] name;
  val tmdl.core.Parameter[*] parameters;
  val Place[+] places;
  val Activity[*] activities;
  val GlobalVariable[*] globalVariables;
  val Arc[*] arcs;
  val Gate[*] gates;
  val Expression[*] initialization;
}

abstract class NamedElement {
  op boolean[1] hasVariability();
  id attr String[1] name;
}

abstract class Place extends NamedElement {
  val tmdl.core.Multiplicity[1] multiplicity;
}

class NormalPlace extends Place {
  val MarkingSimple[1] marking;
}

class ExtendedPlace extends Place {
  val MarkingExtended[1] marking;
  attr ExtendedPlaceType[1] type = "double";
}

abstract class Activity extends NamedElement {
  val CasesSpecification[1] cases;
}

abstract class CasesSpecification {
}

class Case {
  val tmdl.expressions.TemplateExpressionInteger[1] ID;
  val Expression[1] p;
}

class CasesSpecificationCases extends CasesSpecification {
  val Case[+] cases;
}

class CasesSpecificationProbabilityArray extends CasesSpecification {
  ref tmdl.core.ParameterArray[1] pValues;
}

class CasesSpecificationParametric extends CasesSpecification {
  val tmdl.expressions.TemplateExpressionInteger[1] numCases;
  val tmdl.expressions.TemplateExpressionReal[1] pExpression;
}

abstract class Arc {
}

class InputArc extends Arc {
  ref Place[1] source;
  ref Activity[1] target;
}

class OutputArc extends Arc {
  ref Case[1] source;
  ref Place[1] target;
}

@ExtendedMetaData(kind="elementOnly")
abstract class Gate extends NamedElement {
  val Expression[1] function;
  ref Place[*] places;
}

abstract class OutputGate extends Gate {
}

@ExtendedMetaData(kind="elementOnly")
class OutputGateConcrete extends OutputGate {
  ref Case[1] activityCase;
}

@ExtendedMetaData(kind="elementOnly")
class OutputGateTemplate extends OutputGate {
  ref Activity[1] activity;
}

@ExtendedMetaData(kind="elementOnly")
class InputGate extends Gate {
  val Expression[1] predicate;
  ref Activity[1] activity;
}

class InstantaneousActivity extends Activity {
}

class TimedActivity extends Activity {
  val Distribution[1] timeDistribution;
  val Expression activation;
  val Expression reactivation;
}

abstract class Distribution {
}

datatype CodeFragment : java.lang.String;

class Expression {
  val ExpressionSegment[+] segments;
}

abstract interface ExpressionSegment {
}

@ExtendedMetaData
class ExpressionText extends ExpressionSegment {

  @ExtendedMetaData(kind="element")
  attr CodeFragment[1] text;
}

class ExpressionMarking extends ExpressionSegment {
  ref Place[1] place;
  val tmdl.expressions.TemplateExpressionInteger[1] index;
}

class ExpressionVariable extends ExpressionSegment {
  ref GlobalVariable[1] variable;
}

class ExpressionTemplateExpression extends ExpressionSegment {
  val tmdl.expressions.TemplateExpression[1] exp;
}

class ExpressionIterationElement extends ExpressionSegment {
  val VariabilityIterator[1] iterator;
  attr int[1] i;
}

class ExpressionActivityCasesNumber extends ExpressionSegment, tmdl.expressions.TemplateExpressionInteger {

  @"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(body="
			let c = activity.cases
			in
				if c.oclIsTypeOf(CasesSpecificationCases) then
					c.oclAsType(CasesSpecificationCases).cases->size()
				else
					if c.oclIsTypeOf(CasesSpecificationProbabilityArray) then
						c.oclAsType(CasesSpecificationProbabilityArray).pValues->size()
					else
						c.oclAsType(CasesSpecificationParametric).pExpression.evaluate(assignments)
					endif
				endif")
  op int[1] evaluate(!ordered tmdl.core.Assignment[*] assignments);
  ref Activity[1] activity;
}

class ExpressionPlaceTemplateSize extends ExpressionSegment, tmdl.expressions.TemplateExpressionInteger {

  @"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(body="
			let mult = place.multiplicity 
			in
				if mult.oclIsTypeOf(tmdl::core::MultiplicityValue) then
					mult.oclAsType(tmdl::core::MultiplicityValue).value.floor()
				else
					if mult.oclIsTypeOf(tmdl::core::MultiplicityArray) then
						mult.oclAsType(tmdl::core::MultiplicityArray).values->size()
					else
						let par = mult.oclAsType(tmdl::core::MultiplicityParametric).parameter
						in
							if par.oclIsTypeOf(tmdl::core::ParameterSimple) then
								assignments->select(a | a.oclIsTypeOf(tmdl::core::AssignmentSimple))
									->collect(as | as.oclAsType(tmdl::core::AssignmentSimple))
									->select(i | i.parameter = par)
									->asSequence()->first().value
							else
								assignments->select(a | a.oclIsTypeOf(tmdl::core::AssignmentArray))
									->collect(as | as.oclAsType(tmdl::core::AssignmentArray))
									->select(i | i.parameter = par)
									->asSequence()->first().values->size()
							endif
					endif
				endif")
  op int[1] evaluate(!ordered tmdl.core.Assignment[*] assignments);
  ref Place[1] place;
}

class ExpressionIfThenElse extends ExpressionSegment {
  val tmdl.expressions.TemplateExpressionBoolean[1] condition;
  val ExpressionSegment[1] ifTrue;
  val ExpressionSegment ifFalse;
}

class ExpressionLoop extends ExpressionSegment {
  val tmdl.expressions.TemplateExpressionInteger[1] begin;
  val tmdl.expressions.TemplateExpressionInteger[1] end;
  val ExpressionSegment[+] do;
}

abstract interface VariabilityIterator {
}

class ThisContextIterator extends VariabilityIterator {
}

class LoopIterator extends VariabilityIterator {
  ref ExpressionLoop[1] loop;
}

abstract class Marking {
}

class MarkingInteger extends MarkingSimple {
  val tmdl.expressions.TemplateExpressionInteger[1] value;
}

abstract class MarkingExtended extends Marking {
}

enum VariableType {
  short = 0;
  int = 1;
  long = 2;
  float = 3;
  double = 4;
  bool = 5;
  char = 6;
}

class GlobalVariable extends NamedElement {
  attr VariableType[1] type = "int";
}

class MarkingVariableSimple extends MarkingSimple {
  ref GlobalVariable[1] variable;
}

class Exponential extends Distribution {
  val Expression[1] rate;
}

class Normal extends Distribution {
  val Expression[1] mean;
  val Expression[1] variance;
}

class Gamma extends Distribution {
  val Expression[1] alpha;
  val Expression[1] beta;
}

class Binomial extends Distribution {
  val Expression[1] t;
  val Expression[1] p;
}

class Deterministic extends Distribution {
  val Expression[1] value;
}

class Lognormal extends Distribution {
  val Expression[1] mu;
  val Expression[1] alphaSquared;
}

class Beta extends Distribution {
  val Expression[1] alpha1;
  val Expression[1] beta1;
}

class NegativeBinomial extends Distribution {
  val Expression[1] s;
  val Expression[1] p;
}

class Geometric extends Distribution {
  val Expression[1] p;
}

class Erlang extends Distribution {
  val Expression[1] m;
  val Expression[1] beta;
}

class Uniform extends Distribution {
  val Expression[1] lowerBound;
  val Expression[1] upperBound;
}

class HyperExponential extends Distribution {
  val Expression[1] rate0;
  val Expression[1] p0;
}

class Weibull extends Distribution {
  val Expression[1] alpha;
  val Expression[1] beta;
}

class Triangular extends Distribution {
  val Expression[1] min;
  val Expression[1] middle;
  val Expression[1] max;
}

class ConditionalWeibull extends Distribution {
  val Expression[1] alpha;
  val Expression[1] beta;
  val Expression[1] t;
}

class HypoExponential extends Distribution {
  val Expression[1] rate0;
}

class Pareto extends Distribution {
  val Expression[1] lowerBound;
  val Expression[1] shape;
}

abstract class MarkingSimple extends Marking {
}

class MarkingString extends MarkingExtended {
  attr String[1] value = "0";
}

class MarkingVariableExtended extends MarkingExtended {
  ref GlobalVariable[1] variable;
}

enum ExtendedPlaceType {
  int = 1;
  short = 0;
  float = 3;
  double = 4;
  char = 6;
}

