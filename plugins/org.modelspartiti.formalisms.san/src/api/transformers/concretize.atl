-----------------------------------------------------------------------
-- Copyright (C) 2016                                                --
-- University of Firenze, Italy                                      --
--                                                                   --
-- All rights reserved. This program and the accompanying materials  --
-- are made available under the terms of the Eclipse Public License  --
-- v1.0 which accompanies this distribution, and is available at     --
-- http://www.eclipse.org/legal/epl-v10.html                         --
--                                                                   --
-- Contributors:                                                     --
-- Leonardo Montecchi 	lmontecchi@unifi.it                          --
-----------------------------------------------------------------------

-- @nsURI SAN=http://www.modelspartiti.org/templates/san/san
-- @nsURI SANT=http://www.modelspartiti.org/templates/san/sant
-- @nsURI TMDLCO=http://www.modelspartiti.org/infrastructure/tmdl/core
-- @nsURI TMDLEX=http://www.modelspartiti.org/infrastructure/tmdl/expressions
-- @nsURI TMDLLI=http://www.modelspartiti.org/infrastructure/tmdl/library
-- @nsURI TMDLSC=http://www.modelspartiti.org/infrastructure/tmdl/scenario

module concretize;
create concrete : SAN from template : SANT, assignments : TMDLCO, tmdlex : TMDLEX;

helper def: mapPlaceExpansion : Map(SANT!Place, Map(Integer, SAN!Place)) = Map{};

--The SAN/SANT element
rule ModelRoot {
	from
		template : SANT!SANT
	using {
		placesExpanded : Set(SAN!Place) = Set{};
	}
	to
		model : SAN!SAN (
			name <- template.name,
			globalVariables <- template.globalVariables,
			activities <- template.activities,
			gates <- template.gates->select(g | g.oclIsTypeOf(SANT!InputGate) or g.oclIsTypeOf(SANT!OutputGateConcrete))
		)
	do {
		placesExpanded <- template.places->collect(p | thisModule.ExpandPlace(p))->flatten();
		model.places <- placesExpanded;
		model.arcs <- template.arcs->select(a | a.oclIsTypeOf(SANT!InputArc))
						->collect(tia | thisModule.InputArc(tia))
						->union(template.arcs->select(a | a.oclIsTypeOf(SANT!OutputArc))
						->collect(toa | thisModule.OutputArc(toa)))->flatten();
		model.gates <- model.gates.union(template.gates->select(g | g.oclIsTypeOf(SANT!OutputGateTemplate))->collect(ogt | thisModule.OutputGateTemplate(ogt))->flatten());
		model.initialization <- template.initialization->collect(e | thisModule.Expression(e));
	}
}

--Global Variables
rule GlobalVariable {
	from
		tv : SANT!GlobalVariable
	to
		v : SAN!GlobalVariable (
			name <- v.name,
			type <- v.type
		)
}

--Places
rule ExpandPlace(tp : SANT!Place) {
	using {
		places : Set(SAN!Place) = Set{};
		tmpPlace : SAN!Place = OclUndefined;
		mapping : Map(Integer, SAN!Place) = Map{};
	}
	do {
		if(tp.isRegularPlace()) {
			if(tp.oclIsTypeOf(SANT!NormalPlace)) {
				tmpPlace <- thisModule.CreateNormalPlace(tp);
			}else{
				tmpPlace <- thisModule.CreateExtendedPlace(tp);
			}
			places <- places.including(tmpPlace);
			mapping <- mapping->including(1, tmpPlace);
		}else{
			for(i in tp.getMultiplicity()) {
				if(tp.oclIsTypeOf(SANT!NormalPlace)) {
					tmpPlace <- thisModule.CreateNormalPlace(tp);
				}else{
					tmpPlace <- thisModule.CreateExtendedPlace(tp);
				}
				tmpPlace.name <- tmpPlace.name + i;
				places <- places.including(tmpPlace);
				mapping <- mapping->including(i, tmpPlace);
			}
		}
		
		thisModule.mapPlaceExpansion <- thisModule.mapPlaceExpansion.including(tp,mapping);
		places;
	}
}

rule CreateNormalPlace(tp : SANT!NormalPlace) {
	to
		p : SAN!NormalPlace
		(
			name <- tp.name,
			marking <- tp.marking
		)
	do {
		p;
	}
}

rule CreateExtendedPlace(tp : SANT!ExtendedPlace) {
	to
		p : SAN!ExtendedPlace
		(
			name <- tp.name,
			marking <- tp.marking,
			type <- tp.type
		)
	do {
		p;
	}
}

--Marking
abstract rule Marking {
	from
		tm : SANT!Marking
	to
		m : SAN!Marking
}

rule MarkingInteger extends Marking {
	from
		tm : SANT!MarkingInteger
	to
		m : SAN!MarkingInteger
		(
			value <- tm.value.evaluate()
		)
}

rule MarkingVariableSimple extends Marking {
	from
		tm : SANT!MarkingVariableSimple
	to
		m : SAN!MarkingVariableSimple
		(
			variable <- tm.variable
		)
}

rule MarkingString extends Marking {
	from
		tm : SANT!MarkingString
	to
		m : SAN!MarkingString
		(
			value <- tm.value
		)
}

rule MarkingVariableExtended extends Marking {
	from
		tm : SANT!MarkingVariableExtended
	to
		m : SAN!MarkingVariableExtended
		(
			variable <- tm.variable
		)
}

--Activities
abstract rule Activity {
	from
		ta : SANT!Activity
	to
		a : SAN!Activity (
			name <- ta.name
		)
}

rule ActivityInstantaneous extends Activity {
	from
		ta : SANT!InstantaneousActivity
	to
		a : SAN!InstantaneousActivity
	do {
		a.cases <- thisModule.CasesSpecification(ta.cases);
	}
}

rule ActivityTimed extends Activity {
	from
		ta : SANT!TimedActivity
	to
		a : SAN!TimedActivity (
			timeDistribution <- ta.timeDistribution,
			activation <- ta.activation,
			reactivation <- ta.reactivation
		)
	do {
		a.cases <- thisModule.CasesSpecification(ta.cases);
	}
}

--Cases
rule Case {
	from
		tc : SANT!Case
	to
		c : SAN!Case (
			ID <- tc.ID.evaluate()
		)
	do {
		c.p <- thisModule.ExpressionWithContext(tc.p, c.ID);	
	}
}

rule CasesSpecification(cs : SANT!CasesSpecification) {
	using{
		casesList : Sequence(SAN!Case) = Sequence{};	
	}
	do {
		if(cs.oclIsTypeOf(SANT!CasesSpecificationCases)) {
			casesList <- thisModule.CasesSpecificationCases(cs);
		}else{ if(cs.oclIsTypeOf(SANT!CasesSpecificationProbabilityArray)) {
			casesList <- thisModule.CasesSpecificationProbabilityArray(cs);
		}else{ if(cs.oclIsTypeOf(SANT!CasesSpecificationParametric)) {
			casesList <- thisModule.CasesSpecificationParametric(cs);
		}}}
		casesList;
	}
}

rule CasesSpecificationCases(cs : SANT!CasesSpecificationCases) {
	using {
		casesList : Sequence(SAN!Case) = Sequence{};
	}
	do {
		for(c in cs.cases) {
			casesList <- casesList->append(
				thisModule.resolveTemp(c, 'c')
			);
		}
		casesList;
	}
}

rule CasesSpecificationProbabilityArray(cs : SANT!CasesSpecificationProbabilityArray) {
	using {
		casesList : Sequence(SAN!Case) = Sequence{};
		tmpCase : SAN!Case = OclUndefined;
		i : Integer = 0;
	}
	do {
		for(prob in cs.pValues) {
			tmpCase <- SAN!Case.newInstance();
			i <- i+1;
			tmpCase.ID <- i;
			tmpCase.p <- SAN!Expression.newInstance();
			tmpCase.p.segments <- Sequence{SAN!ExpressionText.newInstance()};
			tmpCase.p.segments->first().text <- prob.toString();
			casesList <- casesList.append(tmpCase);
		}
		casesList;
	}
}

rule CasesSpecificationParametric(cs : SANT!CasesSpecificationParametric) {
	using {
		casesList : Sequence(SAN!Case) = Sequence{};
		numCases : Integer = cs.numCases.evaluate();
		seqCases : Sequence(Integer) = numCases.getSequenceFromOne();
		tmpCase : SAN!Case = OclUndefined;
	}
	do {
		for(i in seqCases) {
			tmpCase = SAN!Case.newInstance();
			tmpCase.ID = i;
			tmpCase.p <- thisModule.ExpressionWithContext(cs.pExpression, i);
			casesList <- casesList.append(tmpCase);
		}
		casesList;
	}
}

--Arcs
rule InputArc(tia : SANT!InputArc) {
	using {
		ia : SAN!InputArc = OclUndefined;
		output : Sequence(SAN!InputArc) = Sequence{};
	}
	do {
		for(p in thisModule.mapPlaceExpansion->get(tia.source)->getValues()) {
			ia <- SAN!InputArc.newInstance();
			ia.source <- p;
			ia.target <- thisModule.resolveTemp(tia.target, 'a');
			output <- output.append(ia);
		}
		output;
	}
}

rule OutputArc(toa : SANT!OutputArc) {
	using {
		oa : SAN!OutputArc = OclUndefined;
		output : Sequence(SAN!OutputArc) = Sequence{};
	}
	do {
		for(p in thisModule.mapPlaceExpansion->get(toa.target)->getValues()) {
			oa <- SAN!OutputArc.newInstance();
			oa.source <- thisModule.resolveTemp(toa.source, 'a');
			oa.target <- p;
			output <- output.append(oa);
		}
		output;
	}
}

--Gates
rule InputGate {
	from
		tig : SANT!InputGate
	to
		ig : SAN!InputGate (
			name <- tig.name,
			activity <- tig.activity
		)
	do {
		ig.predicate <- thisModule.Expression(tig.predicate);
		ig.function <- thisModule.Expression(tig.function);
		ig.places <- tig.places->collect(tp | thisModule.mapPlaceExpansion->get(tp)->getValues())->flatten();
	}
}

rule OutputGateConcrete {
	from
		tog : SANT!OutputGateConcrete
	to
		og : SAN!OutputGate (
			name <- tog.name,
			activityCase <- tog.activityCase
		)
	do {
		og.function <- thisModule.Expression(tog.function);	
	}
}

rule OutputGateTemplate(ogt : SANT!OutputGateTemplate) {
	using {
		act : SAN!Activity = thisModule.resolveTemp(ogt.activity, 'a');
		tmpOG : SAN!OutputGate = OclUndefined;
	}
	do {
		for(c in act.cases) {
			tmpOG <- SAN!OutputGate.newInstance();
			tmpOG.name <- ogt.name + c.ID;
			tmpOG.places <- ogt.places->collect(tp | thisModule.mapPlaceExpansion.get(tp)->getValues())->flatten();
			tmpOG.activityCase <- c;
			tmpOG.function <- thisModule.ExpressionWithContext(ogt.function, c.ID);
		}
	}
}

--Expressions
rule Expression(te : SANT!Expression) {
	using {
		exp : SAN!Expression = OclUndefined;	
	}	
	do {
		exp <- thisModule.ExpressionWithContext(te, 1);
		exp;
	}
}

rule ExpressionWithContext(te : SANT!Expression, iContext : Integer) {
	using {
		exp : SAN!Expression = SAN!Expression.newInstance();	
	}	
	do {
		exp.segments <- te.segments->collect(s | thisModule.ExpressionSegment(s,iContext))->flatten();
		exp;
	}
}

rule ExpressionSegment(tes : SANT!ExpressionSegment, iContext : Integer) {
	using {
		segments : Sequence(SAN!ExpressionSegment) = Sequence{};
	}
	do {
		if(tes.oclIsTypeOf(SANT!ExpressionText)) {
			segments <- thisModule.ExpressionText(tes, iContext);
		}else{ if(tes.oclIsTypeOf(SANT!ExpressionMarking)) {
			segments <- thisModule.ExpressionMarking(tes, iContext);
		}else{ if(tes.oclIsTypeOf(SANT!ExpressionVariable)) {
			segments <- thisModule.ExpressionVariable(tes, iContext);
		}else{ if(tes.oclIsTypeOf(SANT!ExpressionTemplateExpression)) {
			segments <- thisModule.ExpressionTemplateExpression(tes, iContext);
		}else{ if(tes.oclIsTypeOf(SANT!ExpressionIterationElement)) {
			segments <- thisModule.ExpressionIterationElement(tes, iContext);
		}else{ if(tes.oclIsTypeOf(SANT!ExpressionActivityCasesNumber)) {
			segments <- thisModule.ExpressionActivityCasesNumber(tes, iContext);
		}else{ if(tes.oclIsTypeOf(SANT!ExpressionPlaceTemplateSize)) {
			segments <- thisModule.ExpressionPlaceTemplateSize(tes, iContext);
		}else{ if(tes.oclIsTypeOf(SANT!ExpressionIfThenElse)) {
			segments <- thisModule.ExpressionIfThenElse(tes, iContext);
		}else{ if(tes.oclIsTypeOf(SANT!ExpressionLoop)) {
			segments <- thisModule.ExpressionLoop(tes, iContext);
		}else{ if(tes.oclIsTypeOf(SANT!ExpressionContext)) {
			segments <- thisModule.ExpressionContext(tes, iContext);
		}}}}}}}}}}
		segments;
	}
}

rule ExpressionText(tes : SANT!ExpressionText, iContext : Integer) {
	using {
		seg : SAN!ExpressionText = SAN!ExpressionText.newInstance();
	}	
	do {
		seg.text <- tes.text;
		Sequence{seg};
	}
}

rule ExpressionMarking(tes : SANT!ExpressionMarking, iContext : Integer) {
	using {
		seg : SAN!ExpressionMarking = SAN!ExpressionMarking.newInstance();
	}	
	do {
		if(tes.index.oclIsTypeOf(SANT!ThisContextIterator)) {
			seg.place <- thisModule.mapPlaceExpansion->get(tes)->get(iContext);	
		}else{
			seg.place <- thisModule.mapPlaceExpansion->get(tes)->get(tes.index.evaluate());
		}
		Sequence{seg};
	}
}

rule ExpressionVariable(tes : SANT!ExpressionVariable, iContext : Integer) {
	using {
		seg : SAN!ExpressionVariable = SAN!ExpressionVariable.newInstance();	
	}
	do {
		seg.variable <- seg.variable;
		Sequence{seg};
	}
}

rule ExpressionTemplateExpression(tes : SANT!ExpressionTemplateExpression, iContext : Integer) {
	using {
		seg : SAN!ExpressionText = SAN!ExpressionText.newInstance();
	}
	do {
		seg.text <- tes.exp.evaluate().toString();
		Sequence{seg};
	}
}

--ExpressionIterationElement
rule ExpressionIterationElement(tes : SANT!ExpressionIterationElement, iContext : Integer) {
	using {
		seg : SAN!ExpressionText = SAN!ExpressionText.newInstance();
	}
	do {
		seg.text <- iContext.toString();
		Sequence{seg};
	}
}

rule ExpressionActivityCasesNumber(tes : SANT!ExpressionActivityCasesNumber, iContext : Integer) {
	using {
		seg : SAN!ExpressionText = SAN!ExpressionText.newInstance();
		act : SAN!Activity = OclUndefined;
	}
	do {
		act <- thisModule.resolveTemp(act, 'a');
		seg.text <- act.cases.size().toString();
		Sequence{seg};
	}
}

rule ExpressionPlaceTemplateSize(tes : SANT!ExpressionPlaceTemplateSize, iContext : Integer) {
	using {
		seg : SAN!ExpressionText = SAN!ExpressionText.newInstance();
	}
	do {
		seg.text <- thisModule.mapPlaceExpansion->get(tes.place)->getValues()->size().toString();
		Sequence{seg};
	}
}

rule ExpressionIfThenElse(tes : SANT!ExpressionIfThenElse, iContext : Integer) {
	using {
		seg : SAN!ExpressionText = SAN!ExpressionText.newInstance();
	}
	do {
		if(tes.condition.evaluate()) {
			seg <- thisModule.ExpressionSegment(tes.ifTrue, iContext);	
		}else{
			seg <- thisModule.ExpressionSegment(tes.ifFalse, iContext);	
		}
		Sequence{seg};
	}
}

rule ExpressionLoop(tes : SANT!ExpressionLoop, iContext : Integer) {
	using {
		segments : Sequence(SAN!ExpressionText) = Sequence{};
		iBegin : Integer = tes.begin.evaluate();
		iEnd : Integer = tes.end.evaluate();
		values : Sequence(Integer) = (iEnd - iBegin + 1).getSequenceFromOne();
		itSegment : SANT!ExpressionIterationElement = OclUndefined;
		iterator : SANT!LoopIterator = OclUndefined;
	}
	do {
		for(i in values) {
			for(tseg in tes.do) {
				if(tseg.oclIsTypeOf(SANT!ExpressionIterationElement)) {
					itSegment <- tseg;
					if(itSegment.iterator.oclIsTypeOf(SANT!LoopIterator)) {
						iterator <- itSegment.iterator;
						if(iterator.loop = tes) {
							segments <- segments->union(thisModule.ExpressionIterationElement(tes, i+iBegin-1));
						}
					}
				}else{
					segments <- segments->union(thisModule.ExpressionSegment(tseg, iContext));	
				}
			}
		}
		segments;
	}
}

rule ExpressionContext(tes : SANT!ExpressionContext, iContext : Integer) {
	using {
		seg : SAN!ExpressionText = SAN!ExpressionText.newInstance();
	}
	do {
		seg.text <- iContext.toString();
		Sequence{seg};
	}
}

--Distributions
abstract rule Distribution {
	from
		td : SANT!Distribution
	to
		d : SAN!Distribution
}

rule Exponential extends Distribution {
	from
		td : SANT!Exponential
	to
		d : SAN!Exponential
	do {
		d.rate <- thisModule.Expression(td.rate);
	}
}

rule Normal extends Distribution {
	from
		td : SANT!Normal
	to
		d : SAN!Normal
	do {
		d.mean <- thisModule.Expression(td.mean);
		d.variance <- thisModule.Expression(td.variance);
	}
}

rule Gamma extends Distribution {
	from
		td : SANT!Gamma
	to
		d : SAN!Gamma
	do {
		d.alpha <- thisModule.Expression(td.alpha);
		d.beta <- thisModule.Expression(td.beta);
	}
}

rule Binomial extends Distribution {
	from
		td : SANT!Binomial
	to
		d : SAN!Binomial
	do {
		d.t <- thisModule.Expression(td.t);
		d.p <- thisModule.Expression(td.p);
	}
}

rule Deterministic extends Distribution {
	from
		td : SANT!Deterministic
	to
		d : SAN!Deterministic
	do {
		d.value <- thisModule.Expression(td.value);
	}
}

rule Lognormal extends Distribution {
	from
		td : SANT!Lognormal
	to
		d : SAN!Lognormal
	do {
		d.mu <- thisModule.Expression(td.mu);
		d.alphaSquared <- thisModule.Expression(td.alphaSquared);
	}
}

rule Beta extends Distribution {
	from
		td : SANT!Beta
	to
		d : SAN!Beta
	do {
		d.alpha1 <- thisModule.Expression(td.alpha1);
		d.beta1 <- thisModule.Expression(td.beta1);
	}
}

rule NegativeBinomial extends Distribution {
	from
		td : SANT!NegativeBinomial
	to
		d : SAN!NegativeBinomial
	do {
		d.s <- thisModule.Expression(td.s);
		d.p <- thisModule.Expression(td.p);
	}
}

rule Geometric extends Distribution {
	from
		td : SANT!Geometric
	to
		d : SAN!Geometric
	do {
		d.p <- thisModule.Expression(td.p);	
	}
}

rule Erlang extends Distribution {
	from
		td : SANT!Erlang
	to
		d : SAN!Erlang
	do {
		d.m <- thisModule.Expression(td.m);
		d.beta <- thisModule.Expression(td.beta);
	}
}

rule Uniform extends Distribution {
	from
		td : SANT!Uniform
	to
		d : SAN!Uniform
	do {
		d.lowerBound <- thisModule.Expression(td.lowerBound);
		d.upperBound <- thisModule.Expression(td.upperBound);
	}
}

rule HyperExponential extends Distribution {
	from
		td : SANT!HyperExponential
	to
		t : SAN!HyperExponential
	do {
		t.rate0 <- thisModule.Expression(td.rate0);
		t.p0 <- thisModule.Expression(td.p0);
	}
}

rule Weibull extends Distribution {
	from
		td : SANT!Weibull
	to
		t : SAN!Weibull
	do {
		t.alpha <- thisModule.Expression(td.alpha);
		t.beta <- thisModule.Expression(td.beta);
	}
}

rule Triangular extends Distribution {
	from
		td : SANT!Triangular
	to
		t : SAN!Triangular
	do {
		t.min <- thisModule.Expression(td.min);
		t.middle <- thisModule.Expression(td.middle);
		t.max <- thisModule.Expression(td.max);
	}
}

rule ConditionalWeibull extends Distribution {
	from
		td : SANT!ConditionalWeibull
	to
		t : SAN!ConditionalWeibull
	do {
		t.alpha <- thisModule.Expression(td.alpha);
		t.beta <- thisModule.Expression(td.beta);
		t.t <- thisModule.Expression(td.t);
	}
}

rule HypoExponential extends Distribution {
	from
		td : SANT!HypoExponential
	to
		t : SAN!HypoExponential
	do {
		t.rate0 <- thisModule.Expression(td.rate0);	
	}
}

rule Pareto extends Distribution {
	from
		td : SANT!Pareto
	to
		t : SAN!Pareto
	do {
		t.lowerBound <- thisModule.Expression(td.lowerBound);
		t.shape <- thisModule.Expression(td.shape);
	}
}

helper context SANT!Place def: isRegularPlace() : Boolean = 
	if self.multiplicity.oclIsTypeOf(SANT!MultiplicityValue) then
		let m : SANT!MultiplicityValue = self.multiplicity in
		m.value = 1
	else
		false
	endif;

helper context SANT!Place def: getMultiplicity() : Set(Integer) =
	self.multiplicity.listValues(TMDLCO!Assignment.allInstances().asSequence());

helper context Integer def: getSequenceFromOne() : Sequence(Integer) = 
	if self = 1 then Sequence{1}
	else (self-1).getSequenceFromOne()->union(Sequence{self}) endif;








