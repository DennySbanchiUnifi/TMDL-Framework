[comment encoding = UTF-8 /]
[module exportSAN('http://www.modelspartiti.org/templates/san/san')]

[comment]Exports an Atomic SAN model in the format of MÃ¶bius 2.5[/comment]

[template public exportSAN(net : SAN)]
[comment @main /]
[file (net.name.concat('.san'), false, 'UTF-8')]
<?xml version="1.0" encoding="ISO-8859-1"?>
<class id="Mobius.AtomicModels.San.SanInterface">
	<int id="ClassVersion">1</int>
	<class id="Mobius.BaseClasses.BaseInterfaceClass">
		<int id="ClassVersion">3</int>
		<string id="ModelName">[net.name/]</string>
		<class id="Mobius.AtomicModels.San.SanEditor">
			<int id="ClassVersion">3</int>
			<class id="Mobius.BaseClasses.BaseEditorClass">
				<int id="ClassVersion">3</int>
				<boolean id="HasPanel">true</boolean>
				<class id="Mobius.BaseClasses.BasePanelClass">
					<int id="ClassVersion">2</int>
					<point id="Size of Panel">
						<int id="x">[canvasSizePixel(net)/]</int>
						<int id="y">[canvasSizePixel(net)/]</int>
					</point>
					<double id="ZoomFactor">1</double>
					<boolean id="ShowGridEnabled">true</boolean>
					<int id="ShowGridStep">10</int>
					<boolean id="SnapGridEnabled">true</boolean>
					<int id="SnapGridStep">10</int>
					[for (p : NormalPlace | net.places->selectByType(NormalPlace))]
					<class id="Mobius.AtomicModels.San.PlacePanelObject">
						<int id="ClassVersion">1</int>
						<class id="Mobius.BaseClasses.BaseVertexClass">
							<int id="ClassVersion">3</int>
							<class id="Mobius.BaseClasses.BasePanelObjectClass">
								<int id="ClassVersion">5</int>
								<string id="Name">[p.name/]</string>
								<boolean id="ContainsLabel">true</boolean>
								<boolean id="IsLabelShown">true</boolean>
							</class>
							<point id="CenterPoint">
								<int id="x">[net.getPositionPixel(p)->at(1)/]</int>
								<int id="y">[net.getPositionPixel(p)->at(2)/]</int>
							</point>
						</class>
						<boolean id="ReadOnly">false</boolean>
						<boolean id="ConstantMarking">[p.marking.oclIsTypeOf(MarkingInteger)/]</boolean>
						[if (p.marking.oclIsTypeOf(MarkingInteger))]
						<int id="InitialState">[p.marking/]</int>
						[else]
						<string id="InitialState">[p.marking/]</string>
						[/if]
					</class>
					[/for]
					[for (p : ExtendedPlace | net.places->selectByType(ExtendedPlace))]
					<class id="Mobius.AtomicModels.San.ExtendedPlacePanelObject">
						<int id="ClassVersion">3</int>
						<class id="Mobius.AtomicModels.San.PlacePanelObject">
							<int id="ClassVersion">1</int>
							<class id="Mobius.BaseClasses.BaseVertexClass">
								<int id="ClassVersion">3</int>
								<class id="Mobius.BaseClasses.BasePanelObjectClass">
									<int id="ClassVersion">5</int>
									<string id="Name">[p.name/]</string>
									<boolean id="ContainsLabel">true</boolean>
									<boolean id="IsLabelShown">true</boolean>
								</class>
								<point id="CenterPoint">
									<int id="x">[net.getPositionPixel(p)->at(1)/]</int>
									<int id="y">[net.getPositionPixel(p)->at(2)/]</int>
								</point>
							</class>
							<boolean id="ReadOnly">false</boolean>
							<boolean id="ConstantMarking">false</boolean>
							<string id="InitialState">[p.marking/]</string>
						</class>
						<string id="initialMarking">[p.marking/]</string>
						<string id="type">[p.type/]</string>
						<int id="fieldCount">1</int>
						<string id="0">[p.marking/]</string>
					</class>
					[/for]
					[for (a : TimedActivity | net.activities->selectByType(TimedActivity))]
					<class id="Mobius.AtomicModels.San.TimedActivityPanelObject">
						<int id="ClassVersion">2</int>
						<class id="Mobius.AtomicModels.San.ActivityPanelObject">
							<int id="ClassVersion">1</int>
							<class id="Mobius.BaseClasses.ExtendedBaseVertexClass">
								<int id="ClassVersion">1</int>
								<class id="Mobius.BaseClasses.BaseVertexClass">
									<int id="ClassVersion">3</int>
									<class id="Mobius.BaseClasses.BasePanelObjectClass">
										<int id="ClassVersion">5</int>
										<string id="Name">[a.name/]</string>
										<boolean id="ContainsLabel">true</boolean>
										<boolean id="IsLabelShown">true</boolean>
									</class>
									<point id="CenterPoint">
										<int id="x">[net.getPositionPixel(a)->at(1)/]</int>
										<int id="y">[net.getPositionPixel(a)->at(2)/]</int>
									</point>
								</class>
							</class>
							<int id="NumberOfCases">[a.cases->size()/]</int>
							<vector id="CaseDistributions">
							[for (c : Case | a.cases)]
								<string id="[c.ID/]">[c.p/]</string>
							[/for]
							</vector>
						</class>
						<class id="Mobius.BaseClasses.Distributions.DistributionFunction">
							<int id="ClassVersion">1</int>
							<string id="Name">[a.timeDistribution.eClass().name/]</string>
							<vector id="MetaParameters">
							</vector>
							<vector id="Parameters">
							[for (exp : Expression | a.timeDistribution.eContents()->selectByType(Expression))]
								<string id="[a.timeDistribution.eContents()->selectByType(Expression)->indexOf(exp)-1/]">[exp/]</string>
							[/for]
							</vector>
						</class>
						<string id="Activation">[a.activation/]</string>
						<string id="Reactivation">[a.reactivation/]</string>
					</class>
					[/for]
					[for (a : InstantaneousActivity | net.activities->selectByType(InstantaneousActivity))]
					<class id="Mobius.AtomicModels.San.InstantaneousActivityPanelObject">
						<int id="ClassVersion">1</int>
						<class id="Mobius.AtomicModels.San.ActivityPanelObject">
							<int id="ClassVersion">1</int>
							<class id="Mobius.BaseClasses.ExtendedBaseVertexClass">
								<int id="ClassVersion">1</int>
								<class id="Mobius.BaseClasses.BaseVertexClass">
									<int id="ClassVersion">3</int>
									<class id="Mobius.BaseClasses.BasePanelObjectClass">
										<int id="ClassVersion">5</int>
										<string id="Name">[a.name/]</string>
										<boolean id="ContainsLabel">true</boolean>
										<boolean id="IsLabelShown">true</boolean>
									</class>
									<point id="CenterPoint">
										<int id="x">[net.getPositionPixel(a)->at(1)/]</int>
										<int id="y">[net.getPositionPixel(a)->at(2)/]</int>
									</point>
								</class>
							</class>
							<int id="NumberOfCases">[a.cases->size()/]</int>
							<vector id="CaseDistributions">
							[for (c : Case | a.cases)]
								<string id="[c.ID/]">[c.p/]</string>
							[/for]
							</vector>
						</class>
					</class>
					[/for]
					[for (g : InputGate | net.gates->selectByType(InputGate))]
					<class id="Mobius.AtomicModels.San.InputGatePanelObject">
						<int id="ClassVersion">1</int>
						<class id="Mobius.BaseClasses.BaseVertexClass">
							<int id="ClassVersion">3</int>
							<class id="Mobius.BaseClasses.BasePanelObjectClass">
								<int id="ClassVersion">5</int>
								<string id="Name">[g.name/]</string>
								<boolean id="ContainsLabel">true</boolean>
								<boolean id="IsLabelShown">true</boolean>
							</class>
							<point id="CenterPoint">
								<int id="x">[net.getPositionPixel(g)->at(1)/]</int>
								<int id="y">[net.getPositionPixel(g)->at(2)/]</int>
							</point>
						</class>
						<boolean id="MirrorImage">false</boolean>
						<string id="Predicate">[g.predicate/]</string>
						<string id="Function">[g.function/]</string>
					</class>
					[/for]
					[for (g : OutputGate | net.gates->selectByType(OutputGate))]
					<class id="Mobius.AtomicModels.San.OutputGatePanelObject">
						<int id="ClassVersion">1</int>
						<class id="Mobius.BaseClasses.BaseVertexClass">
							<int id="ClassVersion">3</int>
							<class id="Mobius.BaseClasses.BasePanelObjectClass">
								<int id="ClassVersion">5</int>
								<string id="Name">[g.name/]</string>
								<boolean id="ContainsLabel">true</boolean>
								<boolean id="IsLabelShown">true</boolean>
							</class>
							<point id="CenterPoint">
								<int id="x">[net.getPositionPixel(g)->at(1)/]</int>
								<int id="y">[net.getPositionPixel(g)->at(2)/]</int>
							</point>
						</class>
						<boolean id="MirrorImage">false</boolean>
						<string id="Function">[g.function/]</string>
					</class>
					[/for]
					[for (a : InputArc | net.arcs->selectByType(InputArc))]
					<class id="Mobius.BaseClasses.BaseEdgeClass">
						<int id="ClassVersion">3</int>
						<int id="LineType">0</int>
						<string id="StartVertex">[a.source.name/]</string>
						<string id="FinishVertex">[a.target.name/]</string>
						<boolean id="Arrows">true</boolean>
						<vector id="PointList">
							<point id="0">
								<int id="x">[net.getPositionPixel(a.source)->at(1)/]</int>
								<int id="y">[net.getPositionPixel(a.source)->at(2)/]</int>
							</point>
							<point id="1">
								<int id="x">[net.getPositionPixel(a.target)->at(1)/]</int>
								<int id="y">[net.getPositionPixel(a.target)->at(2)/]</int>
							</point>
						</vector>
					</class>
					[/for]
					[for (a : OutputArc | net.arcs->selectByType(OutputArc))]
					<class id="Mobius.BaseClasses.BaseEdgeClass">
						<int id="ClassVersion">3</int>
						<int id="LineType">0</int>
						<string id="StartVertex">[a.source.eContainer().oclAsType(Activity).name/]</string>
						<string id="FinishVertex">[a.target.name/]</string>
						<boolean id="Arrows">true</boolean>
						<vector id="PointList">
							<point id="0">
								<int id="x">[net.getCasePositionPixel(a.source)->at(1)/]</int>
								<int id="y">[net.getCasePositionPixel(a.source)->at(2)/]</int>
							</point>
							<point id="1">
								<int id="x">[net.getPositionPixel(a.target)->at(1)/]</int>
								<int id="y">[net.getPositionPixel(a.target)->at(2)/]</int>
							</point>
						</vector>
					</class>
					[/for]
					[for (g : InputGate | net.gates->selectByType(InputGate))]
					<class id="Mobius.BaseClasses.BaseEdgeClass">
						<int id="ClassVersion">3</int>
						<int id="LineType">0</int>
						<string id="StartVertex">[g.name/]</string>
						<string id="FinishVertex">[g.activity.name/]</string>
						<boolean id="Arrows">false</boolean>
						<vector id="PointList">
							<point id="0">
								<int id="x">[net.getPositionPixel(g)->at(1)/]</int>
								<int id="y">[net.getPositionPixel(g)->at(2)/]</int>
							</point>
							<point id="1">
								<int id="x">[net.getPositionPixel(g.activity)->at(1)/]</int>
								<int id="y">[net.getPositionPixel(g.activity)->at(2)/]</int>
							</point>
						</vector>
					</class>
						[for (p : Place | g.places)]
					<class id="Mobius.BaseClasses.BaseEdgeClass">
						<int id="ClassVersion">3</int>
						<int id="LineType">0</int>
						<string id="StartVertex">[p.name/]</string>
						<string id="FinishVertex">[g.name/]</string>
						<boolean id="Arrows">false</boolean>
						<vector id="PointList">
							<point id="0">
								<int id="x">[net.getPositionPixel(p)->at(1)/]</int>
								<int id="y">[net.getPositionPixel(p)->at(2)/]</int>
							</point>
							<point id="1">
								<int id="x">[net.getPositionPixel(g)->at(1)/]</int>
								<int id="y">[net.getPositionPixel(g)->at(2)/]</int>
							</point>
						</vector>
					</class>
						[/for]				
					[/for]
					[for (g : OutputGate | net.gates->selectByType(OutputGate))]
					<class id="Mobius.BaseClasses.BaseEdgeClass">
						<int id="ClassVersion">3</int>
						<int id="LineType">0</int>
						<string id="StartVertex">[g.activityCase.eContainer().oclAsType(Activity).name/]</string>
						<string id="FinishVertex">[g.name/]</string>
						<boolean id="Arrows">false</boolean>
						<vector id="PointList">
							<point id="0">
								<int id="x">[net.getCasePositionPixel(g.activityCase)->at(1)/]</int>
								<int id="y">[net.getCasePositionPixel(g.activityCase)->at(2)/]</int>
							</point>
							<point id="1">
								<int id="x">[net.getPositionPixel(g)->at(1)/]</int>
								<int id="y">[net.getPositionPixel(g)->at(2)/]</int>
							</point>
						</vector>
					</class>
						[for (p : Place | g.places)]
					<class id="Mobius.BaseClasses.BaseEdgeClass">
						<int id="ClassVersion">3</int>
						<int id="LineType">0</int>
						<string id="StartVertex">[g.name/]</string>
						<string id="FinishVertex">[p.name/]</string>
						<boolean id="Arrows">false</boolean>
						<vector id="PointList">
							<point id="0">
								<int id="x">[net.getPositionPixel(g)->at(1)/]</int>
								<int id="y">[net.getPositionPixel(g)->at(2)/]</int>
							</point>
							<point id="1">
								<int id="x">[net.getPositionPixel(p)->at(1)/]</int>
								<int id="y">[net.getPositionPixel(p)->at(2)/]</int>
							</point>
						</vector>
					</class>
						[/for]				
					[/for]
				</class>
				<vector id="LocalGlobalNamesList">
				[for (v : GlobalVariable | net.globalVariables)]
					<string id="[net.globalVariables->indexOf(v)-1/]">[v.name/]</string>
				[/for]
				</vector>
				<vector id="LocalGlobalTypesList">
				[for (v : GlobalVariable | net.globalVariables)]
					<string id="[net.globalVariables->indexOf(v)-1/]">[v.type/]</string>
				[/for]
				</vector>
				<boolean id="DisplayToolTips">true</boolean>
			</class>
		</class>
		<class id="Mobius.AtomicModels.San.SanInfoClass">
			<int id="ClassVersion">5</int>
			<class id="Mobius.BaseClasses.BaseInfoClass">
				<int id="ClassVersion">2</int>
			</class>
			<class id="Mobius.AtomicModels.San.SanTypeManager">
				<int id="ClassVersion">1</int>
				<int id="typeListModelSize">0</int>
			</class>
			<string id="CustomInitialization">[net.initialization/]</string>
		</class>
		<boolean id="Valid">true</boolean>
	</class>
</class>
[/file]
[/template]

[comment]
The queries below are mainly used to compute the graphical position of nodes. 
The size of the panel is computed based on the square root of the total number of "nodes" elements,
i.e., activities, gates, and places. A grid of a fixed dimension is used, and each of them is 
placed in one spot of the grid.
[/comment]

[comment]Calls Math.sqrt from Java libraries[/comment]
[query private sqrt(d : Real) : Real = invoke('java.lang.Math', 'sqrt(double)', Sequence{d}) /]

[comment]Selects SAN elements that should be treated as nodes in the graphical representation[/comment]
[query private getNodes(net : SAN) : Sequence(NamedElement) = 
	net.places->asSequence()->union(net.gates->asSequence())->union(net.activities->asSequence()) /]
[comment] Gets the index of a node among the set of nodes. 
This is used to find the spot in which the node should be placed[/comment]
[query private getIndex(net : SAN, e : OclAny) : Integer = getNodes(net)->indexOf(e) /]

[comment]Computes the size of the panel, in terms of slot in the grid, and in terms of pixels[/comment]
[query private canvasSize(net : SAN) : Integer = (sqrt(getNodes(net)->size())).floor()+1 /]
[query private canvasSizePixel(net: SAN) : Integer =
	(canvasSize(net)+1)*100
/]

[comment]Get the position of a node, in terms of slot in the grid, and in terms of pixels[/comment]
[query private getPosition(net : SAN, e : OclAny) : Sequence(Integer) =
	Sequence{(getIndex(net, e)/canvasSize(net)).floor(), getIndex(net, e).mod(canvasSize(net)).floor()} /]
[query private getPositionPixel(net : SAN, e : OclAny) : Sequence(Integer) = 
	getPosition(net, e)->collect(e | (e+1)*100)	/]

[comment]
Get the position of an activity case in terms of pixels.
This query is of great importance, as Mobius stores the connection between places/gates and cases only in
terms of their graphical position. In the current version it is assumed a region of 11 pixels for each case.
[/comment]
[query private getCasePositionPixel (net : SAN, c : Case) : Sequence(Integer) = 
	let a : Activity = c.eContainer().oclAsType(Activity)
	in
		let act : Sequence(Integer) = getPositionPixel(net, a)
		in Sequence{act->at(1), (act->at(2) - (a.cases->size()*11/2) + c.ID*11 + 11/2).round() } 
/]



